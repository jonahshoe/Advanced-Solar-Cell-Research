import numpy as np
import scipy.integrate as integrate
import matplotlib.pyplot as plt
import pandas as pd

plt.rcParams.update({'font.size': 18})


########## Set sq to 1 to calculate standard Shockley-Queisser limit
########## Set multijunction to 1 to calculate efficiency for two-layer tandem with Si base
########## Set multiexciton to 1 to calculate efficiency for multi-exciton generation
########## Set multijunctionMEG to 1 to calculate efficiency for two-layer tandem with MEG
sq = 0
multijunction = 1
siliconTopLayer = 1 #set to 1 to test bandgaps below Si's (ie treat Si as the top layer as well)
multiexciton = 0 #set meg_cap to desired number
meg_cap = 4 #maximum number of electrons that can be generated by a high-energy photon for multiexciton and multijunctionMEG
multijunctionMEG = 0 #multijunctionMEG is still a work in progress


blackbody = 0 #set to 1 to calculate efficiencies for a blackbody spectrum source
am1pt5 = 1 #set to 1 to calculate efficiencies using AM 1.5 spectrum from nrel


### Set Joules to 1 to run the script in Joule units, eV to 1 to run in eV units. ###
### If both are set to 1, the script will default to eV units. ###

Joules = 0 #run the script in Joules units
eV = 1 #run the script in eV units
q = 1.602176634e-19 #in C

if Joules == 1:
    h = 6.62607015e-34 #in J*s units
    k = 1.380649e-23 #in J/K

if eV == 1:
    h = 6.62607015e-34/q #in eV*s units
    k = 1.380649e-23/q #in eV/K

c = 299792458 #in m/s
Tsun = 5762 #sun temp in K
Tc = 300 #ambient temp in K
g = 2*np.pi/h**3/c**2
qg = q*g
f = (6.957/1495.98)**2 #(radius of sun / distance to sun)^2
C = 1 #concentration factor


if am1pt5 == 1:
    ### Import the AM 1.5 Spectrum (from nrel) ###
    spectrum = np.asarray(pd.read_csv('am1.5spectrum.txt',skiprows=2,sep='\t'))
    wavelength = spectrum[:,0] #in nanometers
    radiance = spectrum[:,3] #in W/s/m^2
    energies = h*c*(wavelength/1e9)**(-1) #The 1e9 factor is to convert wavelength to meters. energies has same units as h

    ### Reverse the arrays to put the data values in order of increasing energy / decreasing wavelength ###
    wavelength = wavelength[::-1]
    radiance = radiance[::-1]
    energies = energies[::-1]


def func(x):
    return x**2/(np.exp(x)-1)

def func2(x):
    return x/(np.exp(x)-1)

def func3(x):
    if np.abs(x) > 1e-2:
        return 1/(np.exp(x)-1)
    elif np.abs(x) <= 1e-2:
        return 1/x #taylor series approx for small x


def Q(egLower,egUpper,T,arrays=0):
    """This function calculates the photon flux for energies from egLower
    to egUpper at temperature T using the quad() integration function from scipy.integrate.
    The units of egLower and egUpper can be either eV or J. The integral's variables have been
    changed to make the integral return a unitless value. The units of the returned value will
    be in whatever energy units k is in."""
    if arrays == 0:
        xgLower = egLower/(k*T)
        xgUpper = egUpper/(k*T)
        integral1 = integrate.quad(func,xgLower,xgUpper,limit=10000)
        if np.isnan(integral1[0]) == False:
            output = integral1[0]
        else:
            output = 0
        return output

    if arrays == 1:
        output = np.zeros([len(egLower)])
        xgUpper = egUpper/(k*T)
        for h in range(len(egLower)):
            xgLower = egLower[h]/(k*T)
            integral1 = integrate.quad(func,xgLower,xgUpper,limit=10000)
            if np.isnan(integral1[0]) == False:
                output[h] = integral1[0]
            else:
                output[h] = 0
        return output

    if arrays == 2:
        output = np.zeros([len(egUpper)])
        xgLower = egLower/(k*T)
        for h in range(len(egUpper)):
            xgUpper = egUpper[h]/(k*T)
            integral1 = integrate.quad(func,xgLower,xgUpper,limit=10000)
            if np.isnan(integral1[0]) == False:
                output[h] = integral1[0]
            else:
                output[h] = 0
        return output

    if arrays == 3:
        output = np.zeros([len(egLower),len(egUpper)])
        for h in range(len(egLower)):
            xgLower = egLower[h]/(k*T)
            for i in range(len(egUpper)):
                xgUpper = egUpper[i]/(k*T)
                if xgLower < xgUpper:
                    integral1 = integrate.quad(func,xgLower,xgUpper,limit=10000)
                    if np.isnan(integral1[0]) == False:
                        output[h,i] = integral1[0]
                    else:
                        output[h,i] = 0
                else:
                    print("Check your energy integral limits!")
                    output[h,i] = 0
        return output

def func4(E,T,V):
    return E**2/(np.exp((E-q*V)/(k*T))-1)

def Q_V(Eg,V):
    """This function calculates the recombination rate for a solar cell with bandgap energy Eg
    operating at temperature T and voltage V. The integral will return the cube of whatever units k is in."""
    output = np.zeros([len(V)])
    for u in range(len(V)):
        if Eg > q*V[u]:
            integral1 = integrate.quad(func4,Eg,np.inf,limit=10000,args=(Tc,V[u]))
            if np.isnan(integral1[0]) == False:
                output[u] = integral1[0]
            else:
                output[u] = 0
        else:
            output[u] = 0
    return output

def Q_V2(Eg1,Eg2,V):
    """This function is the same as Q_V, but with the upper limit added for MEG calculation."""
    output = np.zeros_like(V)
    for u in range(len(V)):
        if Eg1 > q*V[u]:
            integral1 = integrate.quad(func4,Eg1,Eg2,limit=10000,args=(Tc,V[u]))
            if np.isnan(integral1[0]) == False:
                output[u] = integral1[0]
            else:
                output[u] = 0
        else:
            print('Error: Voltage is larger than the bandgap!')
            print('Eg = ', Eg1)
            print('q*V = ', q*V)
            output[u] = 0
    return output

def realsolar(wl,P,eg2,eg1,arrays=0):
    """This function calculates the photon flux for the AM 1.5 solar spectrum imported in line 31.
    he units of the returned value are in photons/m^2/s. wl is the wavelength data in nm, P is the
    radiance/energy flux data in W/m^2/nm, and Eg is the bandgap energy of the material. The wavelength
    is converted to energy using E = hc/wavelength (this will be in units of Joules regardless of what
    option was chosen at the beginning of the script so that it will cancel with the units of P).
    The energy flux P is then divided by the energy to get the photon flux, ie, W/m^2/nm == J/s/m^2/nm,
    so (W/m^2/nm)/J == number of photons/s/m^2/nm. Integration across wavelength then produces units of
    photons/s/m^2. Since it already has s and m^2 in the denominator, it doesn't need to be multiplied by g later."""
    sum = 0
    if Joules == 1:
        energies = h*c*(wavelength/1e9)**(-1)
    if eV == 1:
        energies = h*c*(wavelength/1e9)**(-1)*q
    fluxes = P/energies

    if arrays == 0:
        output = 0
        for i in range(len(wl)):
            if i+1 < len(wl):
                wavelengthtemp = 0.5*(wl[i]+wl[i+1])
                if wavelengthtemp <= h*c/eg2*1e9 and wavelengthtemp >= h*c/eg1*1e9: #the 1e9 factor is to convert the RHS to nm
                    dwl = np.abs((wl[i+1]-wl[i]))
                    output += 0.5*(fluxes[i]+fluxes[i+1])*dwl
        if np.isnan(output) == True:
            output = 0
        return output

    if arrays == 1:
        output = np.zeros([len(eg2)])
        for s in range(len(eg2)):
            for i in range(len(wl)):
                if i+1 < len(wl):
                    wavelengthtemp = 0.5*(wl[i]+wl[i+1])
                    if wavelengthtemp <= h*c/eg2[s]*1e9 and wavelengthtemp >= h*c/eg1*1e9: #the 1e9 factor is to convert the RHS to nm
                        dwl = np.abs((wl[i+1]-wl[i]))
                        output[s] += 0.5*(fluxes[i]+fluxes[i+1])*dwl
            if np.isnan(output[s]) == True:
                output[s] = 0
        return output

    if arrays == 2:
        output = np.zeros([len(eg1)])
        for s in range(len(eg1)):
            for i in range(len(wl)):
                if i+1 < len(wl):
                    wavelengthtemp = 0.5*(wl[i]+wl[i+1])
                    if wavelengthtemp <= h*c/eg2*1e9 and wavelengthtemp >= h*c/eg1[s]*1e9: #the 1e9 factor is to convert the RHS to nm
                        dwl = np.abs((wl[i+1]-wl[i]))
                        output[s] += 0.5*(fluxes[i]+fluxes[i+1])*dwl
            if np.isnan(output[s]) == True:
                output[s] = 0
        return output

    if arrays == 3:
        output = np.zeros([len(eg2),len(eg1)])
        for l in range(len(eg2)):
            for s in range(len(eg1)):
                for i in range(len(wl)):
                    if i+1 < len(wl):
                        wavelengthtemp = 0.5*(wl[i]+wl[i+1])
                        if wavelengthtemp <= h*c/eg2[l]*1e9 and wavelengthtemp >= h*c/eg1[s]*1e9: #the 1e9 factor is to convert the RHS to nm
                            dwl = np.abs((wl[i+1]-wl[i]))
                            output[l,s] += 0.5*(fluxes[i]+fluxes[i+1])*dwl
                if np.isnan(output[l,s]) == True:
                    output[l,s] = 0
        return output

def realpower(wl,P):
    """This function calculates the total incident power per m^2 from the AM 1.5 solar spectrum by
    integrating the radiance P, in units of W/m^2/nm, over all wavelengths. """
    sum = 0
    for i in range(len(wl)):
        if i+1 < len(wl):
            dwl = np.abs((wl[i+1]-wl[i]))
            sum += 0.5*(P[i]+P[i+1])*dwl
    return sum



fignum = 1 #for plotting


if sq == 1:
    if Joules == 1:
        eg = np.linspace(0.2,3,200)*q #in Joules
        P_in = 930 #page 8 of Solar Energy document -- for AM 1.5, intensity is approximately 930 W/m^2
    elif eV == 1:
        eg = np.linspace(0.2,3,200)
        P_in = 930/q
    vcount = 1000 #length of voltage array

    efficiencies = np.zeros([len(eg),vcount])
    efficienciesReal = np.zeros([len(eg),vcount])
    maxEfficiencies = np.zeros_like(eg)
    maxEfficienciesReal = np.zeros_like(eg)
    J = np.zeros([len(eg),vcount])
    JReal = np.zeros([len(eg),vcount])

    ##### Decoder: term1 = absorbed solar flux for blackbody spectrum
    ##### term1Real = absorbed solar flux for AM 1.5 spectrum
    ##### term2 = absorbed ambient flux
    ##### term3 = lost recombined radiation
    for i in range(len(eg)):
        if Joules == 1:
            v = np.linspace(0,eg[i]-0.1,vcount)
        if eV == 1:
            v = np.linspace(0,eg[i]-0.1,vcount)/q #convert from Volts == Joules/Coulomb to eV/Coulomb
        term1 = f*C*Q(eg[i],np.inf,Tsun)
        term1Real = realsolar(wavelength,radiance,eg[i],np.inf)
        term2 = (1-f*C)*Q(eg[i],np.inf,Tc)
        for j in range(vcount):
            ## check to see if the sign of J has changed (but give the first two iterations an exemption) ##
            if j < 2 or J[i,j-2]*J[i,j-1] > 0:
                term3 = Q_V(eg[i],v[j])
                J[i,j] = qg*(term1+term2-term3)
            else:
                J[i,j] = 0

            if j < 2 or JReal[i,j-2]*JReal[i,j-1] > 0:
                term3 = Q_V(eg[i],v[j])
                JReal[i,j] = q*term1Real+qg*(term2-term3)
            else:
                JReal[i,j] = 0

            efficiencies[i,j] = J[i,j]*v[j]/P_in
            efficienciesReal[i,j] = JReal[i,j]*v[j]/P_in
        ## efficiencies and efficienciesReal are the efficiency values for all
        ## voltage values for just the current bandgap energy. The max needs to
        ## be taken to get the maximum possible efficiency at that bandgap energy
        maxEfficiencies[i] = np.max(efficiencies[i])
        maxEfficienciesReal[i] = np.max(efficienciesReal[i])
    plt.figure(fignum)
    fignum += 1
    plt.plot(eg,maxEfficienciesReal,linewidth=3,color='red')
    # plt.title('Single Junction Shockley-Queisser Efficiency Limit')
    plt.xlabel('Bandgap Energy (eV)')
    plt.ylabel('Efficiency')
    print('Finished with Single Junction!')



if multijunction == 1:
    ### Take a smaller step size in regions further from the predicted optimal bandgap energy
    ### by concatenating three arrays with different step sizes for different energy ranges
    egcount = 50
    eglimit1 = 1.101
    eglimit2 = 2.5
    eglimit3 = 0.9
    eglimit4 = 1.099
    if Joules == 1:
        eg1 = np.linspace(eglimit1,eglimit2,egcount)*q
        eg2 = 1.1*q #bandgap for silicon
        if siliconTopLayer == 1:
            eg1_2 = 1.1
            eg2_2 = np.linspace(eglimit3,eglimit4,egcount)*q
        P_in = 900
    elif eV == 1:
        eg1 = np.linspace(eglimit1,eglimit2,egcount)
        eg2 = 1.1
        if siliconTopLayer == 1:
            eg1_2 = 1.1
            eg2_2 = np.linspace(eglimit3,eglimit4,egcount)
        P_in = 900/q #page 8 of Goodnick's document, for AM1.5, intensity is approximately 930 W/m^2

    vcount = 15000




    rhs1 = q*realsolar(wavelength,radiance,eg1,np.inf,arrays=1)
    # rhs1 = qg*f*C*Q(eg1,np.inf,Tsun,arrays=1)
    rhs2 = q*realsolar(wavelength,radiance,eg2,eg1,arrays=2)
    # rhs2 = qg*f*C*Q(eg2,eg1,Tsun,arrays=2)
    # rhs3 = qg*(1-f*C)*Q(eg1,np.inf,Tc,arrays=1)
    # rhs4 = qg*(1-f*C)*Q(eg2,eg1,Tc,arrays=2)
    maxEfficiency = []
    log = open("MJlog.txt","w")
    for i in range(egcount):
        if eg1[i] > eg2:
            rhs2 = q*realsolar(wavelength,radiance,eg2,eg1[i],arrays=0)
        print("{:.3f}".format(eg1[i]), " eV bandgap:")
        print(' ')
        log.write("{:.3f}".format(eg1[i]) + " eV bandgap:\n\n")
        offset = 0.5
        v1 = np.linspace(0,eg1[i]-0.1,vcount)/q
        v2 = np.linspace(0,eg2-0.1,vcount)/q
        bestDiff = 1
        count = 0
        while (bestDiff > 1e-16 and count < 20):
            count += 1
            minDiffList = []
            minDiffArgs = []
            rhs5 = qg*Q_V(eg2,v2)
            rhs6 = qg*Q_V(eg1[i],v2)
            lhs = qg*Q_V(eg1[i],v1)
            # rhs = 2/3*(rhs1[i]-rhs2[i]+rhs3[i]-rhs4[i]+rhs5+rhs6)
            rhs = 2/3*(rhs1[i]-rhs2[i]+rhs5+rhs6)
            for u in range(vcount):
                difference = np.abs(lhs[u]-rhs)
                minDiffList.append(np.min(difference))
                minDiffArgs.append(np.argmin(difference))
            bestDiff = np.min(minDiffList)
            v1argmin = np.argmin(minDiffList)
            v2argmin = minDiffArgs[v1argmin]
            v1best = v1[v1argmin]
            v2best = v2[v2argmin]
            print(np.min(minDiffList), ' at v1 = ', v1best*q, ' J/C and v2 = ', v2best*q, ' J/C.')
            j1best = rhs1[i] - lhs[v1argmin] + rhs6[v2argmin]
            j2best = rhs2[i] - rhs5[v2argmin] + 0.5*lhs[v1argmin]
            efficiency = 0.5*(j1best+j2best)*(v1best+v2best)/P_in
            print('The currents obtained are J1 = ', j1best, ' A/m^2 and J2 = ', j2best, ' A/m^2.')
            log.write("Difference between current densities is " + str(np.min(minDiffList)) + " at v1 = " + str(v1best*q) + " J/C and v2 = " + str(v2best*q) + " J/C.\n")
            log.write("The currents obtained are J1 = " + str(j1best) + " A/m^2 and J2 = " + str(j2best) + " A/m^2.\n\n")
            skips = 1
            while j1best < 0 or j2best < 0:
                print('ERROR: negative currents obtained!')
                log.write('ERROR: negative currents obtained!\n')
                skips *= 2
                minDiffList = []
                minDiffArgs = []
                for u in range(vcount):
                    difference = np.abs(lhs[u]-rhs)
                    difference[difference <= skips*np.min(difference)] = np.max(difference)
                    minDiffList.append(np.min(difference))
                    minDiffArgs.append(np.argmin(difference))
                bestDiff = np.min(minDiffList)
                v1argmin = np.argmin(minDiffList)
                v2argmin = minDiffArgs[v1argmin]
                v1best = v1[v1argmin]
                v2best = v2[v2argmin]
                print(np.min(minDiffList), ' at v1 = ', v1best*q, ' J/C and v2 = ', v2best*q, ' J/C.')
                j1best = rhs1[i] - lhs[v1argmin] + rhs6[v2argmin]
                j2best = rhs2[i] - rhs5[v2argmin] + 0.5*lhs[v1argmin]
                print('The currents obtained are J1 = ', j1best, ' A/m^2 and J2 = ', j2best, ' A/m^2.')
                log.write(str(np.min(minDiffList)) + ' at v1 = ' + str(v1best*q) + ' J/C and v2 = ' + str(v2best*q) + ' J/C.\n')
                log.write('The currents obtained are J1 = ' + str(j1best) + ' A/m^2 and J2 = ' + str(j2best) + ' A/m^2.\n\n')
                efficiency = 0.5*(j1best+j2best)*(v1best+v2best)/P_in


            v1 = np.linspace(v1best*(1-offset),v1best*(1+offset),vcount)
            v2 = np.linspace(v2best*(1-offset),v2best*(1+offset),vcount)
            if count < 3:
                offset *= 0.5
            else:
                offset *= 0.1
            print(' ')
            print(' ')
        if count == 40:
            print('WARNING: Convergence not satisfied')
            log.write('WARNING: Convergence not satisfied\n')
        print(' ')
        print(' ')
        print(' ')
        print('The efficiency for a ', '{:.3f}'.format(eg1[i]), ' eV bandgap top layer is ', '{:.3f}'.format(efficiency))
        log.write('\n\n\nThe efficiency for a ' + '{:.3f}'.format(eg1[i]) + ' eV bandgap top layer is ' + '{:.3f}'.format(efficiency) + '\n\n\n')
        maxEfficiency.append(efficiency)
        print(' ')
        print(' ')
        print(' ')
    log.close()
    plt.plot(eg1,maxEfficiency,'o')
    plt.show()
    e


    if blackbody == 1:
        maxEfficiencyMJ = []
        if siliconTopLayer == 1:
            maxEfficiencyMJ2 = []

    if am1pt5 == 1:
        maxEfficiencyMJReal = []
        if siliconTopLayer == 1:
            maxEfficiencyMJReal2 = []

    ##### This next part calculates all the terms that don't depend on the
    ##### voltages. For each, there is a check to make sure that a Not-a-number
    ##### wasn't returned by any of the integrals. This should have been mostly
    ##### fixed by taking the voltage arrays to the bandgap energies - 0.1 eV,
    ##### but the NaN checks only slow down the computation a little, and save
    ##### a lot of potential headaches, so I left them in.

    ##### Decoder: term1_1 = absorbed solar flux for top layer (first term, first layer).
    ##### term1_2 = absorbed solar flux for silicon base layer (first term, second layer).
    ##### term2_1 = absorbed ambient flux for top layer (second term, first layer).
    ##### term2_2 = absorbed ambient flux for silicon layer (second term, second layer).
    ##### term3_1 = recombined radiation given off by top layer (third term, first layer).
    ##### term3_2 = recomined radiation given off by silicon layer (third term, second layer).
    ##### term4_1 = absorbed flux given off by the silicon layer, absorbed by the top layer (fourth term, first layer).
    ##### term4_2 = absorbed flux given off by the top layer, absorbed by the bottom layer (fourth term, second layer).


    term1_1 = np.zeros([egcount])
    term1_1 = qg*f*C*Q(eg1,np.inf,Tsun,arrays=1)
    term1_2 = np.zeros([egcount])
    term1_2 = qg*f*C*Q(eg2,eg1,Tsun,arrays=2)
    term1_1Real = np.zeros([egcount])
    term1_1Real = q*realsolar(wavelength,radiance,eg1,np.inf,arrays=1)
    term1_2Real = np.zeros([egcount])
    term1_2Real = q*realsolar(wavelength,radiance,eg2,eg1,arrays=2)
    term2_1 = np.zeros([egcount])
    term2_1 = qg*(1-f*C)*Q(eg1,np.inf,Tc,arrays=1)
    term2_2 = np.zeros([egcount])
    term2_2 = qg*(1-f*C)*Q(eg2,eg1,Tc,arrays=2)
    term3_1 = np.zeros([egcount,vcount])
    term3_2 = np.zeros([vcount])
    term4_1 = np.zeros([egcount,vcount])
    term4_2 = np.zeros([egcount,vcount])

    if siliconTopLayer == 1:
        term1_1_2 = qg*f*C*Q(eg1_2,np.inf,Tsun,arrays=0)
        term1_2_2 = np.zeros([egcount])
        term1_2_2 = qg*f*C*Q(eg2_2,eg1_2,Tsun,arrays=1)
        term1_1_2Real = q*realsolar(wavelength,radiance,eg1_2,np.inf,arrays=0)
        term1_2_2Real = np.zeros([egcount])
        term1_2_2Real = q*realsolar(wavelength,radiance,eg2_2,eg1_2,arrays=1)
        term2_1_2 = qg*(1-f*C)*Q(eg1_2,np.inf,Tc,arrays=0)
        term2_2_2 = np.zeros([egcount])
        term2_2_2 = qg*(1-f*C)*Q(eg2_2,eg1_2,Tc,arrays=1)
        term3_1_2 = np.zeros([vcount])
        term3_2_2 = np.zeros([egcount,vcount])
        term4_1_2 = np.zeros([vcount])
        term4_2_2 = np.zeros([vcount])

    if Joules == 1:
        v2 = np.linspace(0,eg2-0.1,vcount)
        if siliconTopLayer == 1:
            v1_2 = np.linspace(0,eg1_2-0.01,vcount)
    if eV == 1:
        v2 = np.linspace(0,eg2-0.1,vcount)/q
        if siliconTopLayer == 1:
            v1_2 = np.linspace(0,eg1_2-0.01,vcount)/q

    term3_2 = qg*Q_V(eg2,v2)
    if siliconTopLayer == 1:
        term3_1_2 = qg*Q_V(eg1_2,v1_2)
        term4_2_2 = 0.5*term3_1_2

    for i in range(egcount):
        print(" ")
        print(" ")
        print("SILICON BOTTOM LAYER: ", "{:.3f}".format(eg1[i]), " eV bandgap.")
        print(" ")
        print("SILICON TOP LAYER: ", "{:.3f}".format(eg2_2[i]), " eV bandgap.")
        print(" ")

        if blackbody == 1:
            j1 = np.zeros([vcount,vcount])
            j2 = np.zeros([vcount,vcount])
            if siliconTopLayer == 1:
                j1_2 = np.zeros([vcount,vcount])
                j2_2 = np.zeros([vcount,vcount])
        if am1pt5 == 1:
            j1Real = np.zeros([vcount,vcount])
            j2Real = np.zeros([vcount,vcount])
            if siliconTopLayer == 1:
                j1_2Real = np.zeros([vcount,vcount])
                j2_2Real = np.zeros([vcount,vcount])

        if Joules == 1:
            v1 = np.linspace(eg1[i]/4,eg1[i]*7/8,vcount)
            if siliconTopLayer == 1:
                v2_2 = np.linspace(0,eg2_2[i]*7/8,vcount)
        if eV == 1:
            v1 = np.linspace(eg1[i]/4,eg1[i]*7/8,vcount)/q
            if siliconTopLayer == 1:
                v2_2 = np.linspace(0,eg2_2[i]*7/8,vcount)/q



        if blackbody == 1:
            index1 = []
            index2 = []
            efficiency = []
            diff = np.zeros([vcount,vcount])
            if siliconTopLayer == 1:
                index1_2 = []
                index2_2 = []
                efficiency2 = []
                diff2 = np.zeros([vcount,vcount])

        if am1pt5 == 1:
            index1Real = []
            index2Real = []
            efficiencyReal = []
            diffReal = np.zeros([vcount,vcount])
            if siliconTopLayer == 1:
                index1_2Real = []
                index2_2Real = []
                efficiencyReal2 = []
                diffReal2 = np.zeros([vcount,vcount])

        term3_1[i] = qg*Q_V(eg1[i],v1)
        term4_1[i] = 0.5*qg*Q_V(eg1[i],v2)
        term4_2[i] = 0.5*term3_1[i]
        if siliconTopLayer == 1:
            term3_2_2[i] = qg*Q_V(eg2_2[i],v2_2)
            term4_1_2 = 0.5*qg*Q_V(eg1_2,v2_2)




        ##### This calculates both layers' current densities, then takes their
        ##### difference and their average. Any pair of current densities
        ##### that satisfies the requirement that their difference divided
        ##### by their average is less than the parameter "threshold" is
        ##### accepted, and their indices are stored in index1 and index2.

        threshold = 1e-3
        threshold2 = 1e-3

        if blackbody == 1:
            print('SILICON AS THE BOTTOM LAYER:')
            for u in range(vcount):
                j1[u] = term1_1[i]+term2_1[i]-term3_1[i,u]+term4_1[i]
                j2[u] = term1_2[i]+term2_2[i]-term3_2+term4_2[i,u]
                if siliconTopLayer == 1:
                    j1_2[u] = term1_1_2+term2_1_2-term3_1_2[u]+term4_1_2
                    j2_2[u] = term1_2_2[i]+term2_2_2[i]-term3_2_2[i]+term4_2_2[u]
            diff = np.abs(j1 - j2)
            diff[j1 <= 0] = np.nan
            diff[j2 <= 0] = np.nan
            diffTemp = diff[np.isnan(diff) == False]
            bestDiffs = diffTemp[diffTemp<threshold]
            while len(bestDiffs) < 10 or len(bestDiffs) > 200:
                if len(bestDiffs) < 10:
                    print('No pairs found. Increasing threshold.')
                    threshold *= 2
                    bestDiffs = diffTemp[diffTemp<threshold]
                elif len(bestDiffs) > 200:
                    print('Too many pairs found. Decreasing threshold.')
                    threshold *= 0.5
                    bestDiffs = diffTemp[diffTemp<threshold]
            for l in range(len(bestDiffs)):
                index1temp, index2temp = np.where(diff == bestDiffs[l])
                index1.append(index1temp[0])
                index2.append(index2temp[0])
            print("Success!")
            print("indices for ", eg1[i], ' eV are ', index1[0], ' and ', index2[0])
            print(" ")
            print('Minimum difference between the currents for bandgap ', eg1[i], ' eV is ', "{:.2f}".format(np.min(diff[np.isnan(diff) == False])), ' for voltages V1 = ', "{:.2f}".format(q*v1[index1[0]]), ' and V2 = ', "{:.2f}".format(q*v2[index2[0]]))
            print('Currents are J1 = ', "{:.2f}".format(j1[index1[0],index2[0]]), ' and J2 = ', "{:.2f}".format(j2[index1[0],index2[0]]))
            print(" ")
            if siliconTopLayer == 1:
                print('SILICON AS THE TOP LAYER:')
                diff2 = np.abs(j1_2 - j2_2)
                diff2[j1_2 <= 0] = np.nan
                diff2[j2_2 <= 0] = np.nan
                diffTemp2 = diff2[np.isnan(diff) == False]
                bestDiffs2 = diffTemp2[diffTemp2<threshold2]
                while len(bestDiffs2) < 10 or len(bestDiffs2) > 200:
                    if len(bestDiffs2) < 10:
                        print('No pairs found. Increasing threshold.')
                        threshold2 *= 2
                        bestDiffs2 = diffTemp2[diffTemp2<threshold2]
                    elif len(bestDiffs2) > 200:
                        print('Too many pairs found. Decreasing threshold.')
                        threshold2 *= 0.6
                        bestDiffs2 = diffTemp2[diffTemp2<threshold2]
                for l in range(len(bestDiffs2)):
                    index1_2temp, index2_2temp = np.where(diff2 == bestDiffs2[l])
                    index1_2.append(index1_2temp[0])
                    index2_2.append(index2_2temp[0])
                print("Success!")
                print(" ")
                print("indices for ", eg2_2[i], ' eV are ', index1_2[0], ' and ', index2_2[0])
                print('Minimum difference between the currents for bandgap ', eg2_2[i], ' eV is ', np.min(diff2[np.isnan(diff2) == False]), ' for voltages V1 = ', q*v1_2[index1_2[0]], ' and V2 = ', q*v2_2[index2_2[0]])
                print('Currents are J1 = ', j1_2[index1_2[0],index2_2[0]], ' and J2 = ', j2_2[index1_2[0],index2_2[0]])
                print(" ")

        if am1pt5 == 1:
            print('SILICON AS THE BOTTOM LAYER:')
            for u in range(vcount):
                j1Real[u] = term1_1Real[i]+term2_1[i]-term3_1[i,u]+term4_1[i]
                j2Real[u] = term1_2Real[i]+term2_2[i]-term3_2+term4_2[i,u]
                if siliconTopLayer == 1:
                    j1_2Real[u] = term1_1_2Real+term2_1_2-term3_1_2[u]+term4_1_2
                    j2_2Real[u] = term1_2_2Real[i]+term2_2_2[i]-term3_2_2[i]+term4_2_2[u]
            diffReal = np.abs(j1Real - j2Real)
            diffReal[j1Real <= 0] = np.nan
            diffReal[j2Real <= 0] = np.nan
            diffTemp = diffReal[np.isnan(diffReal) == False]
            bestDiffs = diffTemp[diffTemp<threshold]
            count = 0
            low = 10
            high = 200
            while (len(bestDiffs) < low or len(bestDiffs) > high) and count < 20:
                while count < 20:
                    if len(bestDiffs) < low:
                        print('Not enough pairs found. Increasing threshold.')
                        threshold *= 1.2
                        bestDiffs = diffTemp[diffTemp<threshold]
                    elif len(bestDiffs) > high:
                        print('Too many pairs found. Decreasing threshold.')
                        threshold *= 0.8
                        bestDiffs = diffTemp[diffTemp<threshold]
                    count += 1
            if len(bestDiffs) < low or len(bestDiffs) > high:
                index1Real = np.array([0])
                index2Real = np.array([0])
            else:
                for l in range(len(bestDiffs)):
                    index1temp, index2temp = np.where(diffReal == bestDiffs[l])
                    index1Real.append(index1temp[0])
                    index2Real.append(index2temp[0])
            print("Success!")
            print("indices for ", "{:.3f}".format(eg1[i]), ' eV are ', index1Real[0], ' and ', index2Real[0])
            print(" ")
            print('Minimum difference between the currents for bandgap ', "{:.3f}".format(eg1[i]), ' eV is ', np.min(diffReal[np.isnan(diffReal) == False]), ' for voltages V1 = ', "{:.2f}".format(q*v1[index1Real[0]]), ' and V2 = ', "{:.2f}".format(q*v2[index2Real[0]]))
            print('Currents are J1 = ', "{:.4f}".format(j1Real[index1Real[0],index2Real[0]]), ' and J2 = ', "{:.4f}".format(j2Real[index1Real[0],index2Real[0]]))
            print(" ")

            if siliconTopLayer == 1:
                print('SILICON AS THE TOP LAYER:')
                diffReal2 = np.abs(j1_2Real - j2_2Real)
                diffReal2[j1_2Real <= 0] = np.nan
                diffReal2[j2_2Real <= 0] = np.nan
                diffTemp2 = diffReal2[np.isnan(diffReal2) == False]
                bestDiffs2 = diffTemp2[diffTemp2<threshold2]
                count = 0
                low = 10
                if len(bestDiffs2) == 0:
                    print('No pairs found for this bandgap. Setting efficiency to 0.')
                    index1_2Real = np.array([0])
                    index2_2Real = np.array([0])
                else:
                    for l in range(len(bestDiffs2)):
                        index1_2temp, index2_2temp = np.where(diffReal2 == bestDiffs2[l])
                        index1_2Real.append(index1_2temp[0])
                        index2_2Real.append(index2_2temp[0])
                        print("Success!")
                        print(" ")
                        print("indices for ", "{:.3f}".format(eg2_2[i]), ' eV are ', index1_2Real[0], ' and ', index2_2Real[0])
                        print('Minimum difference between the currents for bandgap ', "{:.3f}".format(eg2_2[i]), ' eV is ', np.min(diffReal2[np.isnan(diffReal2) == False]), ' for voltages V1 = ', "{:.2f}".format(q*v1_2[index1_2Real[0]]), ' and V2 = ', "{:.2f}".format(q*v2_2[index2_2Real[0]]))
                        print('Currents are J1 = ', "{:.4f}".format(j1_2Real[index1_2Real[0],index2_2Real[0]]), ' and J2 = ', "{:.3f}".format(j2_2Real[index1_2Real[0],index2_2Real[0]]))
                        print(" ")

        ##### This next part calculates the efficiency for each of the pairs of
        ##### current densities that passes the prior threshold criteria. The
        ##### average of the current densities and sum of the voltages are used
        ##### to calculate the produced power. The efficiency and efficiencyReal
        ##### lists are appended with the efficiencies for all of the pairs of
        ##### current densities. The best of these is stored in the maxEfficiencyMJ
        ##### and maxEfficiencyMJReal arrays and the efficiency and efficiencyReal
        ##### arrays will be cleared for the next bandgap energy value.
        if blackbody == 1:
            for b in range(len(index1)):
                j1temp = j1[index1[b],index2[b]]
                j2temp = j2[index1[b],index2[b]]
                jtemp = 0.5*(np.abs(j1temp)+np.abs(j2temp))
                v1temp = v1[index1[b]]
                v2temp = v2[index2[b]]
                vtemp = v1temp + v2temp
                efficiency.append(jtemp*vtemp/P_in)
            maxEfficiencyMJ.append(np.max(np.asarray(efficiency)))

            if siliconTopLayer == 1:
                for b in range(len(index1_2)):
                    j1_2temp = j1_2[index1_2[b],index2_2[b]]
                    j2_2temp = j2_2[index1_2[b],index2_2[b]]
                    jtemp2 = 0.5*(np.abs(j1_2temp)+np.abs(j2_2temp))
                    v1_2temp = v1_2[index1_2[b]]
                    v2_2temp = v2_2[index2_2[b]]
                    vtemp2 = v1_2temp + v2_2temp
                    efficiency2.append(jtemp2*vtemp2/P_in)
                maxEfficiencyMJ2.append(np.max(np.asarray(efficiency2)))



        if am1pt5 == 1:

            for b in range(len(index1Real)):
                j1tempReal = j1Real[index1Real[b],index2Real[b]]
                j2tempReal = j2Real[index1Real[b],index2Real[b]]
                jtempReal = 0.5*(np.abs(j1tempReal)+np.abs(j2tempReal))
                v1tempReal = v1[index1Real[b]]
                v2tempReal = v2[index2Real[b]]
                vtempReal = v1tempReal + v2tempReal
                efficiencyReal.append(jtempReal*vtempReal/P_in)
            maxEfficiencyMJReal.append(np.max(np.asarray(efficiencyReal)))

            if siliconTopLayer == 1:
                for b in range(len(index1_2Real)):
                    j1_2tempReal = j1_2Real[index1_2Real[b],index2_2Real[b]]
                    j2_2tempReal = j2_2Real[index1_2Real[b],index2_2Real[b]]
                    jtempReal2 = 0.5*(np.abs(j1_2tempReal)+np.abs(j2_2tempReal))
                    v1_2tempReal = v1_2[index1_2Real[b]]
                    v2_2tempReal = v2_2[index2_2Real[b]]
                    vtempReal2 = v1_2tempReal + v2_2tempReal
                    efficiencyReal2.append(jtempReal2*vtempReal2/P_in)
                maxEfficiencyMJReal2.append(np.max(np.asarray(efficiencyReal2)))

    plt.figure(fignum)
    fignum += 1
    if blackbody == 1:
        plt.plot(eg1,maxEfficiencyMJ)
    if am1pt5 == 1:
        plt.plot(eg1,maxEfficiencyMJReal,linewidth=3,color='black')
        if siliconTopLayer == 1:
            plt.plot(eg2_2,maxEfficiencyMJReal2,linewidth=3,color='blue')
    # plt.title('Two-Layer Tandem Solar Cell with Silicon Base Layer')
    plt.xlabel('Bandgap Energy of Top Layer (eV)')
    plt.ylabel('Efficiency')
    plt.xlim(0.2,3.2)
    plt.ylim(0,0.49)
    print('Finished with the Multi-Junction!')
    # plt.figure(fignum)
    # fignum += 1
    # plt.plot(v1*q,term3_1[0],color='blue')
    # plt.plot(v1*q,term3_1[1],color='red')
    # plt.plot(v1*q,term3_1[2],color='green')
    # plt.axhline(term1_1Real[0]+term2_1[0],color='orange')
    # plt.axhline(term1_1Real[1]+term2_1[1],color='firebrick')
    # plt.axhline(term1_1Real[2]+term2_1[2],color='cyan')
    # plt.axhline(term1_2Real[0]+term2_2[0],color='teal')
    # plt.axhline(term1_2Real[1]+term2_2[1],color='gold')
    # plt.axhline(term1_2Real[2]+term2_2[2],color='skyblue')
    # plt.ylabel(r'Current Density J (A/m$^2$)')
    # plt.xlabel('Top Layer Voltage (J/C)')
    # plt.ylim(-15,500)



if multiexciton == 1:
    vcount = 200
    egcount = 150
    eglower = 0.2
    egupper = 2.5

    if Joules == 1:
        eg = np.linspace(eglower,egupper,egcount)*q #in Joules
        P_in = 930
    elif eV == 1:
        eg = np.linspace(eglower,egupper,egcount)
        P_in = 930/q #page 8 of Goodnick's document, for AM1.5, intensity is approximately 930 W/m^2


    def efficiency(meg):
        """This function takes a maximum value of excitons generated per photon
        and calculates the efficiency of a cell in which every photon
        generates the max number of excitons possible for its energy, up to the
        value of meg. It returns an array of maximum efficiencies as a function
        of bandgap energy."""
        if blackbody == 1:
            n = np.zeros([egcount,vcount])
            nmax = np.zeros_like(eg)
            j1 = np.zeros([egcount,vcount])

        if am1pt5 == 1:
            n_real = np.zeros([egcount,vcount])
            nmax_real = np.zeros_like(eg)
            j1real = np.zeros([egcount,vcount])

        for i in range(egcount):
            if Joules == 1:
                v = np.linspace(0,eg[i]-0.1,vcount)
            if eV == 1:
                v = np.linspace(0,eg[i]-0.1,vcount)/q

            if blackbody == 1:
                term1 = np.zeros([meg])
            if am1pt5 == 1:
                term1_real = np.zeros([meg])
            term2 = np.zeros([meg])

            ##### This for loop will repeat for every possible number of excitons
            ##### generated. Term 1, the incident solar photon flux, and term 2,
            ##### the ambient incident photon flux, have been split into a series of
            ##### integrals, ie, integral(Eg to inf) is replaced with integral(Eg to 2*Eg)
            ##### + 2*integral(2*Eg to 3*Eg) + 3*integral(3*Eg to 4*Eg) + ... up to
            ##### the maximum provided by meg. This loop cycles through every interval,
            ##### from Eg to 2Eg, 2Eg to 3Eg, etc, and stores the result of each integral
            ##### inside of term1[u], term1_real, term2[u].
            for u in range(meg):
                if u+1 < meg:
                    if blackbody == 1:
                        term1[u] = (u+1)*f*C*Q((u+1)*eg[i],(u+2)*eg[i],Tsun)
                    if am1pt5 == 1:
                        term1_real[u] = (u+1)*realsolar(wavelength,radiance,(u+1)*eg[i],(u+2)*eg[i])
                    term2[u] = (u+1)*(1-f*C)*Q((u+1)*eg[i],(u+2)*eg[i],Tc)
                elif u+1 == meg:
                    if blackbody == 1:
                        term1[u] = (u+1)*f*C*Q((u+1)*eg[i],np.inf,Tsun)
                    if am1pt5 == 1:
                        term1_real[u] = (u+1)*realsolar(wavelength,radiance,(u+1)*eg[i],np.inf)
                    term2[u] = (u+1)*(1-f*C)*Q((u+1)*eg[i],np.inf,Tc)

            ##### This for loop cycles through all of the voltage values, calculates
            ##### term3 for each, then loops through meg again to add all of the
            ##### term1[u], term2[u], etc integrals found in the previous loop.
            ##### The efficiency is calculated for each current density found.
            for j in range(vcount):
                term3 = np.zeros([meg])
                for u in range(meg):
                    if u+1 < meg:
                        term3[u] = (u+1)*Q_V2((u+1)*eg[i],(u+2)*eg[i],v[j])
                    elif u+1 == meg:
                        term3[u] = (u+1)*Q_V2((u+1)*eg[i],np.inf,v[j])

                if blackbody == 1:
                    if j < 2 or j1[i,j-2]*j1[i,j-1] > 0:
                        for u in range(meg):
                            j1[i,j] += qg*(term1[u]+term2[u])
                            j1[i,j] -= qg*term3[u]
                    else:
                        j1[i,j] = 0
                    n[i,j] = j1[i,j]*v[j]/P_in

                if am1pt5 == 1:
                    if j < 2 or j1real[i,j-2]*j1real[i,j-1] > 0:
                        for u in range(meg):
                            j1real[i,j] += q*term1_real[u]+qg*term2[u]
                            j1real[i,j] -= qg*term3[u]
                    else:
                        j1real[i,j] = 0
                    n_real[i,j] = j1real[i,j]*v[j]/P_in

            if blackbody == 1:
                nmax[i] = np.max(n[i])
            if am1pt5 == 1:
                nmax_real[i] = np.max(n_real[i])

        if blackbody == 1:
            if am1pt5 == 1:
                return nmax, nmax_real
            if am1pt5 == 0:
                return nmax
        else:
            return nmax_real

    ##### This next loop will cycle through meg_cap and will return the max
    ##### efficiencies for each possible max number of excitons less than or equal
    ##### to meg_cap. Ie, for meg_cap = 2, the max efficiencies for single-exciton
    ##### generation *and* double-exciton generation will be returned and graphed.
    if blackbody == 1:
        nmax_array = np.zeros([meg_cap,egcount])
    if am1pt5 == 1:
        nmax_real_array = np.zeros([meg_cap,egcount])
    plt.figure(fignum)
    fignum += 1
    for jk in range(meg_cap):
        if blackbody == 1:
            if am1pt5 == 1:
                nmax_array[jk],nmax_real_array[jk] = efficiency(jk+1)
                plt.plot(eg,nmax_real_array[jk])
                plt.plot(eg,nmax_real[jk])
            if am1pt5 == 0:
                nmax_array[jk] = efficiency(jk+1)
                plt.plot(eg,nmax_real[jk],linewidth=3)
        else:
            nmax_real_array[jk] = efficiency(jk+1)
    plt.plot(eg,nmax_real_array[2],linewidth=3,color='blue')
    plt.plot(eg,nmax_real_array[3],linewidth=3,color='purple')
    plt.plot(eg,nmax_real_array[5],linewidth=3,color='black')
    # plt.title('Shockley-Queisser Limit with Multi-Exciton Generation for ' + str(meg_cap) + ' Max Exciton(s) per Photon')
    plt.xlabel('Bandgap Energy (eV)')
    plt.ylim(0,0.45)
    plt.xlim(0,2.5)
    plt.ylabel('Efficiency')
    print('Finished with the multi-exciton generation!')



if multijunctionMEG == 1:
    egcount = 30
    eglimit1 = 1.101
    eglimit2 = 3.0
    eglimit3 = 0.4
    eglimit4 = 1.099
    if Joules == 1:
        eg1 = np.linspace(eglimit1,eglimit2,egcount)*q
        eg2 = 1.1*q #bandgap for silicon
        P_in = 930
        if siliconTopLayer == 1:
            eg1flip = 1.1
            eg2flip = np.linspace(eglimit3,eglimit4,egcount)*q
    elif eV == 1:
        eg1 = np.linspace(eglimit1,eglimit2,egcount)
        eg2 = 1.1
        P_in = 930/q #page 8 of Goodnick's document, for AM1.5, intensity is approximately 930 W/m^2
        if siliconTopLayer == 1:
            eg1flip = 1.1
            eg2flip = np.linspace(eglimit3,eglimit4,egcount)

    vcount = 6000

    if Joules == 1:
        v2 = np.linspace(0,eg2-0.1,vcount)
        if siliconTopLayer == 1:
            v1flip = np.linspace(0,eg1flip-0.1,vcount)
    if eV == 1:
        v2 = np.linspace(0,eg2-0.1,vcount)/q
        if siliconTopLayer == 1:
            v1flip = np.linspace(0,eg1flip-0.1,vcount)/q

    if blackbody == 1:
        j1 = np.zeros([vcount,vcount])
        j2 = np.zeros([vcount,vcount])
        maxEfficiency = []
        finalDiff = []
        if siliconTopLayer == 1:
            j1flip = np.zeros([vcount,vcount])
            j2flip = np.zeros([vcount,vcount])
            maxEfficiencyflip = []
            finalDiff_flip = []

    if am1pt5 == 1:
        j1AM15 = np.zeros([vcount,vcount])
        j2AM15 = np.zeros([vcount,vcount])
        maxEfficiencyAM15 = []
        finalDiffAM15 = []
        if siliconTopLayer == 1:
            j1AM15flip = np.zeros([vcount,vcount])
            j2AM15flip = np.zeros([vcount,vcount])
            maxEfficiencyAM15flip = []
            finalDiffAM15flip = []

    term1_1 = np.zeros([egcount])
    term1_2 = np.zeros([egcount])
    term1_1AM15 = np.zeros([egcount])
    term1_2AM15 = np.zeros([egcount])
    term2_1 = np.zeros([egcount])
    term2_2 = np.zeros([egcount])
    term3_1 = np.zeros([egcount,vcount])
    term3_2 = np.zeros([egcount,vcount])
    term4_1 = np.zeros([egcount,vcount])
    term4_2 = np.zeros([egcount,vcount])

    if siliconTopLayer == 1:
        term1_1flip = np.zeros([egcount])
        term1_2flip = np.zeros([egcount])
        term1_1AM15flip = np.zeros([egcount])
        term1_2AM15flip = np.zeros([egcount])
        term2_1flip = np.zeros([egcount])
        term2_2flip = np.zeros([egcount])
        term3_1flip = np.zeros([egcount,vcount])
        term3_2flip = np.zeros([egcount,vcount])
        term4_1flip = np.zeros([egcount,vcount])
        term4_2flip = np.zeros([egcount,vcount])

    max_meg_layer2 = meg_cap

    for i in range(egcount):
        max_si_meg = eg1[i]/eg2
        max_si_meg = max_si_meg.astype(int)
        if max_si_meg > meg_cap:
            max_si_meg = meg_cap

        max_bottom_meg_flip = eg1flip/eg2flip[i]
        max_bottom_meg_flip = max_bottom_meg_flip.astype(int)
        if max_bottom_meg_flip > meg_cap:
            max_bottom_meg_flip = meg_cap

        if Joules == 1:
            v1 = np.linspace(0,eg1[i]-0.1,vcount)
            if siliconTopLayer == 1:
                v2flip = np.linspace(0,eg2flip[i]-0.1,vcount)
        if eV == 1:
            v1 = np.linspace(0,eg1[i]-0.1,vcount)/q
            if siliconTopLayer == 1:
                v2flip = np.linspace(0,eg2flip[i]-0.1,vcount)/q

        if blackbody == 1:
            index1 = []
            index2 = []
            efficiency = []
            diff = np.zeros([vcount,vcount])
            if siliconTopLayer == 1:
                index1flip = []
                index2flip = []
                efficiencyflip = []
                diff_flip = np.zeros([vcount,vcount])

        if am1pt5 == 1:
            index1AM15 = []
            index2AM15 = []
            efficiencyAM15 = []
            diffAM15 = np.zeros([vcount,vcount])
            if siliconTopLayer == 1:
                index1AM15flip = []
                index2AM15flip = []
                efficiencyAM15flip = []
                diffAM15flip = np.zeros([vcount,vcount])

        for u in range(max_meg_layer2):
            if u+1 < max_meg_layer2:
                if blackbody == 1:
                    term1_1[i] += (u+1)*qg*f*C*Q((u+1)*eg1[i],(u+2)*eg1[i],Tsun)
                    if siliconTopLayer == 1:
                        term1_1flip[i] += (u+1)*qg*f*C*Q((u+1)*eg1flip,(u+2)*eg1flip,Tsun)
                if am1pt5 == 1:
                    term1_1AM15[i] += (u+1)*q*realsolar(wavelength,radiance,(u+1)*eg1[i],(u+2)*eg1[i])
                    if siliconTopLayer == 1:
                        term1_1AM15flip[i] += (u+1)*q*realsolar(wavelength,radiance,(u+1)*eg1flip,(u+2)*eg1flip)
                term2_1[i] += (u+1)*qg*(1-f*C)*Q((u+1)*eg1[i],(u+2)*eg1[i],Tc)
                term3_1[i] += (u+1)*qg*Q_V2((u+1)*eg1[i],(u+2)*eg1[i],v1)
                term4_1[i] += 0.5*(u+1)*qg*Q_V2((u+1)*eg1[i],(u+2)*eg1[i],v2)
                if siliconTopLayer == 1:
                    term2_1flip[i] += (u+1)*qg*(1-f*C)*Q((u+1)*eg1flip,(u+2)*eg1flip,Tc)
                    term3_1flip[i] += (u+1)*qg*Q_V2((u+1)*eg1flip,(u+2)*eg1flip,v1flip)
                    term4_1[i] += 0.5*(u+1)*qg*Q_V2((u+1)*eg1[i],(u+2)*eg1flip,v2flip)
            elif u+1 == max_meg_layer2:
                if blackbody == 1:
                    term1_1[i] += (u+1)*qg*f*C*Q((u+1)*eg1[i],np.inf,Tsun)
                    if siliconTopLayer == 1:
                        term1_1flip[i] += (u+1)*qg*f*C*Q((u+1)*eg1flip,np.inf,Tsun)
                if am1pt5 == 1:
                    term1_1AM15[i] += (u+1)*q*realsolar(wavelength,radiance,(u+1)*eg1[i],np.inf)
                    if siliconTopLayer == 1:
                        term1_1AM15flip[i] += (u+1)*q*realsolar(wavelength,radiance,(u+1)*eg1flip,np.inf)
                term2_1[i] += (u+1)*qg*(1-f*C)*Q((u+1)*eg1[i],np.inf,Tc)
                term3_1[i] += (u+1)*qg*Q_V2((u+1)*eg1[i],np.inf,v1)
                term4_1[i] += 0.5*(u+1)*qg*Q_V2((u+1)*eg1[i],np.inf,v2)
                if siliconTopLayer == 1:
                    term2_1flip[i] += (u+1)*qg*(1-f*C)*Q((u+1)*eg1flip,np.inf,Tc)
                    term3_1flip[i] += (u+1)*qg*Q_V2((u+1)*eg1flip,np.inf,v1flip)
                    term4_1flip[i] += 0.5*(u+1)*qg*Q_V2((u+1)*eg1flip,np.inf,v2flip)


        for r in range(max_si_meg):
            if r+1 < max_si_meg:
                if blackbody == 1:
                    term1_2[i] += (r+1)*qg*f*C*Q((r+1)*eg2,(r+2)*eg2,Tsun)
                if am1pt5 == 1:
                    term1_2AM15[i] += (r+1)*q*realsolar(wavelength,radiance,(r+1)*eg2,(r+2)*eg2)
                term2_2[i] += (r+1)*qg*(1-f*C)*Q((r+1)*eg2,(r+2)*eg2,Tc)
                term3_2[i] += (r+1)*qg*Q_V2((r+1)*eg2,(r+2)*eg2,v2)
            elif r+1 == max_si_meg:
                if blackbody == 1:
                    term1_2[i] += (r+1)*qg*f*C*Q((r+1)*eg2,eg1[i],Tsun)
                if am1pt5 == 1:
                    term1_2AM15[i] += (r+1)*q*realsolar(wavelength,radiance,(r+1)*eg2,eg1[i])
                term2_2[i] += (r+1)*qg*(1-f*C)*Q((r+1)*eg2,eg1[i],Tc)
                term3_2[i] += (r+1)*qg*Q_V2((r+1)*eg2,np.inf,v2)
        term4_2[i] = 0.5*term3_1[i]
        if siliconTopLayer == 1:
            for r in range(max_bottom_meg_flip):
                if r+1 < max_bottom_meg_flip:
                    if blackbody == 1:
                        term1_2flip[i] += (r+1)*qg*f*C*Q((r+1)*eg2flip[i],(r+2)*eg2flip[i],Tsun)
                    if am1pt5 == 1:
                        term1_2AM15flip[i] += (r+1)*q*realsolar(wavelength,radiance,(r+1)*eg2flip[i],(r+2)*eg2flip[i])
                    term2_2flip[i] += (r+1)*qg*(1-f*C)*Q((r+1)*eg2flip[i],(r+2)*eg2flip[i],Tc)
                    term3_2flip[i] += (r+1)*qg*Q_V2((r+1)*eg2flip[i],(r+2)*eg2flip[i],v2flip)
                elif r+1 == max_si_meg:
                    if blackbody == 1:
                        term1_2flip[i] += (r+1)*qg*f*C*Q((r+1)*eg2flip[i],eg1flip,Tsun)
                    if am1pt5 == 1:
                        term1_2AM15flip[i] += (r+1)*q*realsolar(wavelength,radiance,(r+1)*eg2flip[i],eg1flip)
                    term2_2flip[i] += (r+1)*qg*(1-f*C)*Q((r+1)*eg2flip[i],eg1flip,Tc)
                    term3_2flip[i] += (r+1)*qg*Q_V2((r+1)*eg2flip[i],np.inf,v2flip)
            term4_2flip[i] = 0.5*term3_1flip[i]

        threshold = 1e-3
        threshold2 = 1e-2

        if blackbody == 1:
            print('SILICON AS THE BOTTOM LAYER:')
            for u in range(vcount):
                j1[u] = term1_1[i]+term2_1[i]-term3_1[i,u]+term4_1[i]
                j2[u] = term1_2[i]+term2_2[i]-term3_2[i]+term4_2[i,u]
                if siliconTopLayer == 1:
                    j1flip[u] = term1_1flip[i]+term2_1flip[i]-term3_1flip[i,u]+term4_1flip[i]
                    j2flip[u] = term1_2flip[i]+term2_2flip[i]-term3_2flip[i]+term4_2flip[u]
            diff = np.abs(j1 - j2)
            diff[j1 <= 0] = np.nan
            diff[j2 <= 0] = np.nan
            diffTemp = diff[np.isnan(diff) == False]
            bestDiffs = diffTemp[diffTemp<threshold]
            while len(bestDiffs) < 10 or len(bestDiffs) > 200:
                if len(bestDiffs) < 10:
                    print('No pairs found. Increasing threshold.')
                    threshold *= 2
                    bestDiffs = diffTemp[diffTemp<threshold]
                elif len(bestDiffs) > 200:
                    print('Too many pairs found. Decreasing threshold.')
                    threshold *= 0.5
                    bestDiffs = diffTemp[diffTemp<threshold]
            for l in range(len(bestDiffs)):
                index1temp, index2temp = np.where(diff == bestDiffs[l])
                index1.append(index1temp[0])
                index2.append(index2temp[0])
            print("Success!")
            print("indices for ", eg1[i], ' eV are ', index1[0], ' and ', index2[0])
            print(" ")
            print('Minimum difference between the currents for bandgap ', eg1[i], ' eV is ', "{:.2f}".format(np.min(diff[np.isnan(diff) == False])), ' for voltages V1 = ', "{:.2f}".format(q*v1[index1[0]]), ' and V2 = ', "{:.2f}".format(q*v2[index2[0]]))
            print('Currents are J1 = ', "{:.2f}".format(j1[index1[0],index2[0]]), ' and J2 = ', "{:.2f}".format(j2[index1[0],index2[0]]))
            print(" ")
            if siliconTopLayer == 1:
                print('SILICON AS THE TOP LAYER:')
                diff_flip = np.abs(j1flip - j2flip)
                diff_flip[j1flip <= 0] = np.nan
                diff_flip[j2flip <= 0] = np.nan
                diffTempflip = diff_flip[np.isnan(diff_flip) == False]
                bestDiffsflip = diffTempflip[diffTempflip<threshold2]
                while len(bestDiffsflip) < 10 or len(bestDiffsflip) > 200:
                    if len(bestDiffsflip) < 10:
                        print('No pairs found. Increasing threshold.')
                        threshold2 *= 2
                        bestDiffsflip = diffTempflip[diffTempflip<threshold2]
                    elif len(bestDiffsflip) > 200:
                        print('Too many pairs found. Decreasing threshold.')
                        threshold2 *= 0.6
                        bestDiffsflip = diffTempflip[diffTempflip<threshold2]
                for l in range(len(bestDiffsflip)):
                    index1_2temp, index2_2temp = np.where(diff_flip == bestDiffsflip[l])
                    index1flip.append(index1_2temp[0])
                    index2flip.append(index2_2temp[0])
                print("Success!")
                print(" ")
                print("indices for ", eg2flip[i], ' eV are ', index1flip[0], ' and ', index2flip[0])
                print('Minimum difference between the currents for bandgap ', eg2flip[i], ' eV is ', np.min(diff_flip[np.isnan(diff_flip) == False]), ' for voltages V1 = ', q*v1flip[index1flip[0]], ' and V2 = ', q*v2flip[index2flip[0]])
                print('Currents are J1 = ', j1flip[index1flip[0],index2flip[0]], ' and J2 = ', j2flip[index1flip[0],index2flip[0]])
                print(" ")

        if am1pt5 == 1:
            print('SILICON AS THE BOTTOM LAYER:')
            for u in range(vcount):
                j1AM15[u] = term1_1AM15[i]+term2_1[i]-term3_1[i,u]+term4_1[i]
                j2AM15[u] = term1_2AM15[i]+term2_2[i]-term3_2[i]+term4_2[i,u]
                if siliconTopLayer == 1:
                    j1AM15flip[u] = term1_1AM15flip[i]+term2_1flip[i]-term3_1flip[i,u]+term4_1flip[i]
                    j2AM15flip[u] = term1_2AM15flip[i]+term2_2flip[i]-term3_2flip[i]+term4_2flip[i,u]
            diffAM15 = np.abs(j1AM15 - j2AM15)
            diffAM15[j1AM15 <= 0] = np.nan
            diffAM15[j2AM15 <= 0] = np.nan
            diffTemp = diffAM15[np.isnan(diffAM15) == False]
            bestDiffs = diffTemp[diffTemp<threshold]
            count = 0
            low = 10
            high = 200
            while (len(bestDiffs) < low or len(bestDiffs) > high):
                while count < 20:
                    if len(bestDiffs) < low:
                        print('Not enough pairs found. Increasing threshold.')
                        threshold *= 2
                        bestDiffs = diffTemp[diffTemp<threshold]
                    elif len(bestDiffs) > high:
                        print('Too many pairs found. Decreasing threshold.')
                        threshold *= 0.6
                        bestDiffs = diffTemp[diffTemp<threshold]
                    count += 1
                low = int(low/2)
                high *= 2
            for l in range(len(bestDiffs)):
                index1temp, index2temp = np.where(diffAM15 == bestDiffs[l])
                index1AM15.append(index1temp[0])
                index2AM15.append(index2temp[0])
            print("Success!")
            print("indices for ", "{:.3f}".format(eg1[i]), ' eV are ', index1AM15[0], ' and ', index2AM15[0])
            print(" ")
            print('Minimum difference between the currents for bandgap ', "{:.3f}".format(eg1[i]), ' eV is ', np.min(diffAM15[np.isnan(diffAM15) == False]), ' for voltages V1 = ', "{:.2f}".format(q*v1[index1AM15[0]]), ' and V2 = ', "{:.2f}".format(q*v2[index2AM15[0]]))
            print('Currents are J1 = ', "{:.4f}".format(j1AM15[index1AM15[0],index2AM15[0]]), ' and J2 = ', "{:.4f}".format(j2AM15[index1AM15[0],index2AM15[0]]))
            print(" ")

            if siliconTopLayer == 1:
                print('SILICON AS THE TOP LAYER:')
                diffAM15flip = np.abs(j1AM15flip - j2AM15flip)
                diffAM15flip[j1AM15flip <= 0] = np.nan
                diffAM15flip[j2AM15flip <= 0] = np.nan
                diffTempflip = diffAM15flip[np.isnan(diffAM15flip) == False]
                bestDiffsflip = diffTempflip[diffTempflip<threshold2]
                low = 10
                high = 200
                max = 1000
                count = 0
                while (len(bestDiffsflip) < low or len(bestDiffsflip) > high) and count < 20:
                    count += 1
                    if len(bestDiffsflip) < low:
                        print('Not enough pairs found. Increasing threshold.')
                        threshold2 *= 1.5
                        bestDiffsflip = diffTempflip[diffTempflip<threshold2]
                    if len(bestDiffsflip) > high:
                        print('Too many pairs found. Attempting to lower threshold.')
                        threshold2 *= 0.8
                        bestDiffsflip = diffTempflip[diffTempflip<threshold2]
                        count += 1
                print(len(bestDiffsflip))
                if len(bestDiffsflip) != 0 and len(bestDiffsflip) < high:
                    for l in range(len(bestDiffsflip)):
                        index1tempflip, index2tempflip = np.where(diffAM15flip == bestDiffsflip[l])
                        index1AM15flip.append(index1tempflip[0])
                        index2AM15flip.append(index2tempflip[0])
                if len(bestDiffsflip) > high or len(bestDiffsflip) == 0:
                    print('Decreasing the threshold is not working. Selecting the minimum non-zero difference.')
                    diffTempflip[diffTempflip == 0] = np.max(diffTempflip)
                    bestDiffsflip = diffTempflip[np.argmin(diffTempflip)]
                    index1tempflip, index2tempflip = np.where(diffAM15flip == bestDiffsflip)
                    index1AM15flip.append(index1tempflip[0])
                    index2AM15flip.append(index2tempflip[0])

                print("Success!")
                print(" ")
                print("indices for ", "{:.3f}".format(eg2flip[i]), ' eV are ', index1AM15flip[0], ' and ', index2AM15flip[0])
                print('Minimum difference between the currents for bandgap ', "{:.3f}".format(eg2flip[i]), ' eV is ', np.min(diffAM15flip[np.isnan(diffAM15flip) == False]), ' for voltages V1 = ', "{:.2f}".format(q*v1flip[index1AM15flip[0]]), ' and V2 = ', "{:.2f}".format(q*v2flip[index2AM15flip[0]]))
                print('Currents are J1 = ', "{:.4f}".format(j1AM15flip[index1AM15flip[0],index2AM15flip[0]]), ' and J2 = ', "{:.3f}".format(j2AM15flip[index1AM15flip[0],index2AM15flip[0]]))
                print(" ")

        ##### This next part calculates the efficiency for each of the pairs of
        ##### current densities that passes the prior threshold criteria. The
        ##### average of the current densities and sum of the voltages are used
        ##### to calculate the produced power. The efficiency and efficiencyAM15
        ##### lists are appended with the efficiencies for all of the pairs of
        ##### current densities. The best of these is stored in the maxEfficiencyMJ
        ##### and maxEfficiencyMJAM15 arrays and the efficiency and efficiencyAM15
        ##### arrays will be cleared for the next bandgap energy value.
        if blackbody == 1:
            for b in range(len(index1)):
                j1temp = j1[index1[b],index2[b]]
                j2temp = j2[index1[b],index2[b]]
                jtemp = 0.5*(np.abs(j1temp)+np.abs(j2temp))
                v1temp = v1[index1[b]]
                v2temp = v2[index2[b]]
                vtemp = v1temp + v2temp
                efficiency.append(jtemp*vtemp/P_in)
            maxEfficiency.append(np.max(np.asarray(efficiency)))

            if siliconTopLayer == 1:
                for b in range(len(index1_2)):
                    j1tempflip = j1flip[index1flip[b],index2flip[b]]
                    j2tempflip = j2flip[index1flip[b],index2flip[b]]
                    jtempflip = 0.5*(np.abs(j1tempflip)+np.abs(j2tempflip))
                    v1tempflip = v1flip[index1flip[b]]
                    v2tempflip = v2flip[index2flip[b]]
                    vtempflip = v1tempflip + v2tempflip
                    efficiencyflip.append(jtempflip*vtempflip/P_in)
                maxEfficiencyflip.append(np.max(np.asarray(efficiencyflip)))



        if am1pt5 == 1:
            for b in range(len(index1AM15)):
                j1tempAM15 = j1AM15[index1AM15[b],index2AM15[b]]
                j2tempAM15 = j2AM15[index1AM15[b],index2AM15[b]]
                jtempAM15 = 0.5*(np.abs(j1tempAM15)+np.abs(j2tempAM15))
                v1tempAM15 = v1[index1AM15[b]]
                v2tempAM15 = v2[index2AM15[b]]
                vtempAM15 = v1tempAM15 + v2tempAM15
                efficiencyAM15.append(jtempAM15*vtempAM15/P_in)
            maxEfficiencyAM15.append(np.max(np.asarray(efficiencyAM15)))


            if siliconTopLayer == 1:
                j1tempAM15flip = np.zeros([len(index1AM15flip)])
                j2tempAM15flip = np.zeros([len(index1AM15flip)])
                v1tempAM15flip = np.zeros([len(index1AM15flip)])
                v2tempAM15flip = np.zeros([len(index1AM15flip)])
                efficiencyAM15flip = np.zeros([len(index1AM15flip)])
                for b in range(len(index1AM15flip)):
                    j1tempAM15flip[b] = j1AM15flip[index1AM15flip[b],index2AM15flip[b]]
                    j2tempAM15flip[b] = j2AM15flip[index1AM15flip[b],index2AM15flip[b]]
                    v1tempAM15flip[b] = v1flip[index1AM15flip[b]]
                    v2tempAM15flip[b] = v2flip[index2AM15flip[b]]
                jtempAM15flip = 0.5*(np.abs(j1tempAM15flip)+np.abs(j2tempAM15flip))
                vtempAM15flip = v1tempAM15flip + v2tempAM15flip
                efficiencyAM15flip = jtempAM15flip*vtempAM15flip/P_in
                maxEfficiencyAM15flip.append(np.max(np.asarray(efficiencyAM15flip)))
    plt.figure(fignum)
    fignum += 1
    if blackbody == 1:
        plt.plot(eg1,maxEfficiency)
    if am1pt5 == 1:
        plt.plot(eg1,maxEfficiencyAM15,linewidth=3,color='black')
        if siliconTopLayer == 1:
            plt.plot(eg2flip,maxEfficiencyAM15flip,linewidth=3,color='blue')
    # plt.title('Two-Layer Tandem Solar Cell with Silicon Base Layer')
    plt.xlabel('Bandgap Energy of Top Layer (eV)')
    plt.ylabel('Efficiency')
    plt.xlim(0.2,3.2)
    plt.ylim(0,0.49)
    print('Finished with the Multi-Junction!')
    print('Finished with the Multi-Junction!')



plt.show()












e
